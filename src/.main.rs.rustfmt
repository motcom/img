use atty;
use clap::{Arg, Args, Command};
use eframe;
use egui;
use image::{self, PixelWithColorType};
use std::env;
use std::io::BufRead;
use std::path::Path;

fn main() {

   /// コマンドライン引数の解析
    let pipe_flag:bool;
    if atty::isnt(atty::Stream::Stdin) {
        println!("パイプ入力");
        pipe_flag = true;
    } else {
        println!("ファイル入力");
        pipe_flag = false;
    }


   /// コマンドライン引数の解析
    let img_path_str: Vec<Path> = if pipe_flag {
        // パイプ入力の場合
        let mut buffer = String::new();
        std::io::stdin().lock().read_line(&mut buffer).unwrap();
       let tmp_split_str = buffer.split('\n');
        let vec: Vec<Path> = vec::new();
        for str in tmp_split_str {
           Path::as_ref(&str);
        }
    } else {
        // ファイル入力の場合
        env::args()
            .collect::<Vec<String>>()
            .get(1)
            .expect("画像ファイルを指定してください")
            .to_string()
    };


    let path = Path::new(&img_path_str);
    if !Path::is_file(path) {
        eprintln!("指定ファイルがありません");
   
   }

    // eframを使ってウィンドウを作成
    eframe::run_native(
        "my_app",
        eframe::NativeOptions::default(),
        Box::new(|_| Ok(Box::new(MyApp::new()))),
    )
    .expect("Failed to run eframe");
}

struct MyApp {
    tex_id: egui::TextureId,
    tex_size: (usize, usize),
    checked: bool,
}
impl MyApp {
    fn new() -> Self {
        Self {
            checked: false,
            tex_size: (0, 0),
            tex_id: egui::TextureId::default(),
        }
    }
}

impl eframe::App for MyApp {
    fn update(&mut self, ctx: &egui::Context, _: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.add(egui::Checkbox::new(&mut self.checked, "Check me"));
        });
    }
}
